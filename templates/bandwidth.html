{% extends 'base.html' %}
{% block content %}
<div class="d-flex align-items-center justify-content-between mb-2">
  <h3 class="mb-0">Bandwidth Monitors</h3>
  <div class="d-flex align-items-center gap-2">
    <label class="me-1">Refresh</label>
    <select id="interval" class="form-select form-select-sm" style="width:auto;">
      <option value="1000">1s</option>
      <option value="3000" selected>3s</option>
      <option value="5000">5s</option>
    </select>
    <button id="clearCache" class="btn btn-sm btn-outline-warning">Clear Cache</button>
  </div>
  </div>

<div class="card mb-3">
  <div class="card-body">
    <form id="addForm" class="row g-2 align-items-end">
      <div class="col-md-4">
        <label class="form-label">Device</label>
        <select id="addDevice" class="form-select" required>
          <option value="" selected disabled>Select device</option>
          {% for d in devices %}
          <option value="{{ d.id }}">{{ d.name }} ({{ d.host }})</option>
          {% endfor %}
        </select>
      </div>
      <div class="col-md-4">
        <label class="form-label">Interface</label>
        <select id="addIface" class="form-select" required disabled>
          <option value="" selected disabled>Select interface</option>
        </select>
      </div>
      <div class="col-md-2">
        <label class="form-label">Name</label>
        <input id="addName" type="text" class="form-control" placeholder="Label (optional)">
      </div>
      <div class="col-md-2">
        <button class="btn btn-primary w-100" type="submit">Add Monitor</button>
      </div>
    </form>
  </div>
  </div>

<div class="table-responsive">
  <table class="table table-bordered align-middle" id="monTable">
    <thead class="table-light">
      <tr>
        <th>No</th>
        <th>Device Name</th>
        <th>Interface Name</th>
        <th>Name</th>
        <th>RX Bandwidth (Mbps)</th>
        <th>TX Bandwidth (Mbps)</th>
        <th></th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  </div>

<script>
(() => {
  const addDevice = document.getElementById('addDevice');
  const addIface = document.getElementById('addIface');
  const addForm = document.getElementById('addForm');
  const tableBody = document.querySelector('#monTable tbody');
  const intervalSel = document.getElementById('interval');

  let timer = null;
  let rows = []; // {id, device_id, device_name, iface, name, rx_el, tx_el, lastCounters}

  function saveRows() {
    try {
      const toSave = rows.map(r => ({
        device_id: r.device_id,
        device_name: r.device_name,
        iface: r.iface.replace(/^"(.*)"$/, '$1'), // Remove surrounding quotes before saving
        name: r.name || ''
      }));
      localStorage.setItem('bw_rows', JSON.stringify(toSave));
      localStorage.setItem('bw_interval', intervalSel.value || '3000');
    } catch {}
  }

  // Clear any cached data with quotes
  function clearCache() {
    localStorage.removeItem('bw_rows');
    localStorage.removeItem('bw_interval');
    rows = [];
    renderRows();
  }

  function restoreRows() {
    try {
      const saved = JSON.parse(localStorage.getItem('bw_rows') || '[]');
      const savedInterval = localStorage.getItem('bw_interval');
      if (savedInterval) intervalSel.value = savedInterval;
      if (Array.isArray(saved)) {
        rows = saved.map(o => ({
          device_id: String(o.device_id),
          device_name: o.device_name,
          iface: o.iface.replace(/^"(.*)"$/, '$1'), // Remove surrounding quotes
          name: o.name || '',
          rx_el: null,
          tx_el: null,
          lastCounters: null
        }));
        renderRows();
      }
    } catch {}
  }

  async function loadInterfacesForSelected() {
    addIface.innerHTML = '<option value="" disabled selected>Loading...</option>';
    addIface.disabled = true;
    const id = addDevice.value;
    if (!id) return;
    try {
      const r = await fetch(`/api/bandwidth/interfaces?device_id=${id}`);
      const j = await r.json();
      addIface.innerHTML = '<option value="" disabled selected>Select interface</option>';
      (j.interfaces || []).forEach(n => {
        const opt = document.createElement('option'); opt.value = n; opt.textContent = n; addIface.appendChild(opt);
      });
      addIface.disabled = false;
    } catch {
      addIface.innerHTML = '<option value="" disabled selected>Error</option>';
    }
  }

  function renderRows() {
    tableBody.innerHTML = '';
    rows.forEach((row, idx) => {
      const tr = document.createElement('tr');
      const tdNo = document.createElement('td'); tdNo.textContent = String(idx + 1);
      const tdDev = document.createElement('td'); tdDev.textContent = row.device_name;
      const tdIf = document.createElement('td'); tdIf.textContent = row.iface;
      const tdName = document.createElement('td'); tdName.textContent = row.name || '-';
      const tdRx = document.createElement('td'); row.rx_el = tdRx; tdRx.textContent = '-';
      const tdTx = document.createElement('td'); row.tx_el = tdTx; tdTx.textContent = '-';
      const tdAct = document.createElement('td');
      const probe = document.createElement('button'); probe.className = 'btn btn-sm btn-outline-info me-2'; probe.textContent = 'Probe';
      const btn = document.createElement('button'); btn.className = 'btn btn-sm btn-outline-danger'; btn.textContent = 'Remove';
      probe.addEventListener('click', async () => {
        probe.disabled = true; probe.textContent = 'Probing...';
        try {
          const r = await fetch(`/api/bandwidth/probe?device_id=${row.device_id}&interface=${row.iface}`);
          const j = await r.json();
          alert('Path: ' + (j.path || '-') + '\nSSH bytes: ' + JSON.stringify(j.ssh_bytes) + '\nSSH monitor bps: ' + j.ssh_monitor_rx_bps + '/' + j.ssh_monitor_tx_bps + '\nSNMP bytes: ' + JSON.stringify(j.snmp_bytes));
        } catch(e) {
          alert('Probe failed');
        } finally {
          probe.disabled = false; probe.textContent = 'Probe';
        }
      });
      btn.addEventListener('click', () => {
        rows = rows.filter(r => r !== row);
        renderRows();
        saveRows();
      });
      tdAct.appendChild(probe); tdAct.appendChild(btn);
      tr.appendChild(tdNo); tr.appendChild(tdDev); tr.appendChild(tdIf); tr.appendChild(tdName); tr.appendChild(tdRx); tr.appendChild(tdTx); tr.appendChild(tdAct);
      tableBody.appendChild(tr);
    });
  }

  async function pollRow(row) {
    try {
      const r = await fetch(`/api/bandwidth/sample?device_id=${row.device_id}&interface=${row.iface}`);
      const j = await r.json();
      const nowTs = Date.now();
      if (j && j.error) {
        row.rx_el.textContent = 'error'; row.tx_el.textContent = 'error';
        return;
      }
      let rxMbps = null, txMbps = null;
      if ('rx_bps' in j) { rxMbps = (j.rx_bps || 0)/1_000_000; txMbps = (j.tx_bps || 0)/1_000_000; }
      else if ('rx_bytes' in j && row.lastCounters) {
        const dt = (nowTs - row.lastCounters.ts)/1000; if (dt > 0) {
          const rx_bps = ((j.rx_bytes - row.lastCounters.rx_bytes)*8)/dt; const tx_bps = ((j.tx_bytes - row.lastCounters.tx_bytes)*8)/dt;
          rxMbps = Math.max(0, rx_bps)/1_000_000; txMbps = Math.max(0, tx_bps)/1_000_000;
        }
      }
      if ('rx_bytes' in j) {
        if (!row.lastCounters) {
          row.rx_el.textContent = '...'; row.tx_el.textContent = '...';
        }
        row.lastCounters = { ts: nowTs, rx_bytes: j.rx_bytes, tx_bytes: j.tx_bytes };
      } else {
        row.lastCounters = null;
      }
      if (rxMbps != null) row.rx_el.textContent = rxMbps.toFixed(2);
      if (txMbps != null) row.tx_el.textContent = txMbps.toFixed(2);
    } catch {
      row.rx_el.textContent = 'error'; row.tx_el.textContent = 'error';
    }
  }

  async function pollAll() {
    await Promise.all(rows.map(pollRow));
  }

  function startTimer() {
    if (timer) clearInterval(timer);
    const ms = parseInt(intervalSel.value || '3000', 10);
    timer = setInterval(pollAll, ms);
    saveRows();
  }

  addDevice.addEventListener('change', loadInterfacesForSelected);
  addForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const devId = addDevice.value; const iface = addIface.value; const name = document.getElementById('addName').value.trim();
    if (!devId || !iface) return;
    const devName = addDevice.options[addDevice.selectedIndex].textContent;
    rows.push({ device_id: devId, device_name: devName, iface, name, rx_el: null, tx_el: null, lastCounters: null });
    renderRows();
    saveRows();
    // immediate first poll
    pollRow(rows[rows.length - 1]);
  });

  intervalSel.addEventListener('change', () => startTimer());

  // Clear cache on page load to remove any quoted interface names
  clearCache();

  // Add event listener for clear cache button
  document.getElementById('clearCache').addEventListener('click', () => {
    clearCache();
    alert('Cache cleared! Please refresh the page.');
  });

  // initial
  restoreRows();
  startTimer();
  pollAll();
})();
</script>
{% endblock %}


