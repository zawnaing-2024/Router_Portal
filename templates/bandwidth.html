{% extends 'base.html' %}
{% block content %}
<div class="d-flex align-items-center justify-content-between mb-2">
  <h3 class="mb-0">Bandwidth Dashboard</h3>
  <button id="addPanel" class="btn btn-sm btn-primary">Add Panel</button>
  </div>

<div id="panels" class="row g-3"></div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@3.5.0/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
<script>
(() => {
  const panelsEl = document.getElementById('panels');
  const addPanelBtn = document.getElementById('addPanel');

  function makeEl(tag, cls) { const el = document.createElement(tag); if (cls) el.className = cls; return el; }

  function applyScale(chart, scaleVal) {
    const y = chart.options.scales.y;
    if (scaleVal === 'auto') {
      y.min = 0; y.max = undefined; y.ticks = y.ticks || {}; y.ticks.stepSize = undefined;
    } else {
      const max = parseInt(scaleVal, 10); // Mbps
      y.min = 0; y.max = max; y.ticks = y.ticks || {}; y.ticks.stepSize = 10; // 0,10,20,...
    }
    chart.update('none');
  }

  function createPanel() {
    const col = makeEl('div', 'col-12');
    const card = makeEl('div', 'card');
    const body = makeEl('div', 'card-body');

    const row = makeEl('div', 'row g-2 align-items-end');

    const devCol = makeEl('div', 'col-md-3');
    const devLbl = makeEl('label', 'form-label'); devLbl.textContent = 'Device';
    const devSel = makeEl('select', 'form-select');
    devSel.innerHTML = '<option value="" selected disabled>Select device</option>';
    {% for d in devices %}
    { const opt = document.createElement('option'); opt.value = '{{ d.id }}'; opt.textContent = '{{ d.name }} ({{ d.host }})'; devSel.appendChild(opt); }
    {% endfor %}
    devCol.appendChild(devLbl); devCol.appendChild(devSel);

    const ifCol = makeEl('div', 'col-md-3');
    const ifLbl = makeEl('label', 'form-label'); ifLbl.textContent = 'Interface';
    const ifSel = makeEl('select', 'form-select'); ifSel.disabled = true; ifSel.innerHTML = '<option value="" disabled selected>Select interface</option>';
    ifCol.appendChild(ifLbl); ifCol.appendChild(ifSel);

    const winCol = makeEl('div', 'col-md-2');
    const winLbl = makeEl('label', 'form-label'); winLbl.textContent = 'Window';
    const winSel = makeEl('select', 'form-select');
    winSel.innerHTML = '<option value="60">1 minute</option><option value="300">5 minutes</option><option value="900">15 minutes</option>';
    winCol.appendChild(winLbl); winCol.appendChild(winSel);

    const scaleCol = makeEl('div', 'col-md-3');
    const scaleLbl = makeEl('label', 'form-label'); scaleLbl.textContent = 'Scale (Mbps)';
    const scaleSel = makeEl('select', 'form-select');
    scaleSel.innerHTML = '<option value="auto">Auto</option><option value="100">100 Mbps</option><option value="1000">1,000 Mbps (1 Gbps)</option><option value="10000">10,000 Mbps (10 Gbps)</option>';
    scaleCol.appendChild(scaleLbl); scaleCol.appendChild(scaleSel);

    const remCol = makeEl('div', 'col-md-1 text-end');
    const remBtn = makeEl('button', 'btn btn-outline-danger btn-sm'); remBtn.textContent = 'Remove';
    remCol.appendChild(remBtn);

    row.appendChild(devCol); row.appendChild(ifCol); row.appendChild(winCol); row.appendChild(scaleCol); row.appendChild(remCol);

    // Second control row: height and time range
    const row2 = makeEl('div', 'row g-2 align-items-end mt-1');
    const hCol = makeEl('div', 'col-md-2');
    const hLbl = makeEl('label', 'form-label'); hLbl.textContent = 'Height';
    const hSel = makeEl('select', 'form-select');
    hSel.innerHTML = '<option value="60">Small</option><option value="90" selected>Medium</option><option value="140">Large</option>';
    hCol.appendChild(hLbl); hCol.appendChild(hSel);

    const fromCol = makeEl('div', 'col-md-4');
    const fromLbl = makeEl('label', 'form-label'); fromLbl.textContent = 'From';
    const fromInp = makeEl('input', 'form-control'); fromInp.type = 'datetime-local';
    fromCol.appendChild(fromLbl); fromCol.appendChild(fromInp);

    const toCol = makeEl('div', 'col-md-4');
    const toLbl = makeEl('label', 'form-label'); toLbl.textContent = 'To';
    const toInp = makeEl('input', 'form-control'); toInp.type = 'datetime-local';
    toCol.appendChild(toLbl); toCol.appendChild(toInp);

    const rangeCol = makeEl('div', 'col-md-2');
    const applyBtn = makeEl('button', 'btn btn-outline-primary w-100'); applyBtn.textContent = 'Apply Range';
    const clearBtn = makeEl('button', 'btn btn-outline-secondary w-100 mt-1'); clearBtn.textContent = 'Clear Range';
    rangeCol.appendChild(applyBtn); rangeCol.appendChild(clearBtn);
    row2.appendChild(hCol); row2.appendChild(fromCol); row2.appendChild(toCol); row2.appendChild(rangeCol);

    const canvas = document.createElement('canvas'); canvas.height = 90;
    body.appendChild(row); body.appendChild(row2); body.appendChild(makeEl('hr', 'my-2'));
    body.appendChild(canvas);
    card.appendChild(body); col.appendChild(card); panelsEl.appendChild(col);

    const ctx = canvas.getContext('2d');
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'RX (Mbps)',
            data: [],
            borderColor: '#0d6efd',
            backgroundColor: 'rgba(13,110,253,0.08)',
            borderWidth: 1.5,
            pointRadius: 0,
            tension: 0.25,
            fill: true
          },
          {
            label: 'TX (Mbps)',
            data: [],
            borderColor: '#198754',
            backgroundColor: 'rgba(25,135,84,0.08)',
            borderWidth: 1.5,
            pointRadius: 0,
            tension: 0.25,
            fill: true
          }
        ]
      },
      options: {
        responsive: true,
        animation: false,
        maintainAspectRatio: false,
        interaction: { mode:'index', intersect:false },
        scales: {
          x: {
            type: 'time',
            time: { unit: 'second', displayFormats: { second: 'HH:mm:ss' } },
            title: { display: true, text: 'Time' },
            grid: { color: 'rgba(0,0,0,0.05)' }
          },
          y: {
            beginAtZero: true,
            title: { display: true, text: 'Mbps' },
            grid: { color: 'rgba(0,0,0,0.05)' }
          }
        },
        plugins: {
          legend: { display: true, position: 'top' },
          tooltip: {
            callbacks: {
              label: (ctx) => `${ctx.dataset.label}: ${Number(ctx.parsed.y).toFixed(2)} Mbps`
            }
          }
        }
      }
    });

    let timer = null;
    let lastCounters = null; // for linux
    const buffer = []; // {ts, rx, tx}
    let activeRange = null; // {from, to} in ms

    async function loadIfaces() {
      ifSel.disabled = true; ifSel.innerHTML = '<option value="" disabled selected>Loading...</option>';
      const id = devSel.value; if (!id) return;
      try {
        const r = await fetch(`/api/bandwidth/interfaces?device_id=${id}`);
        const j = await r.json();
        ifSel.innerHTML = '<option value="" disabled selected>Select interface</option>';
        (j.interfaces || []).forEach(n => { const o = document.createElement('option'); o.value = n; o.textContent = n; ifSel.appendChild(o); });
        ifSel.disabled = false;
      } catch {}
    }

    function resetChart() {
      chart.data.labels = []; chart.data.datasets[0].data = []; chart.data.datasets[1].data = []; chart.update('none');
    }

    function trimBuffer() {
      const maxSecs = parseInt(winSel.value || '60', 10); const now = Date.now();
      const cutoff = now - maxSecs * 1000;
      while (buffer.length > 0 && buffer[0].ts < cutoff) buffer.shift();
    }

    function renderFromBuffer() {
      const maxSecs = parseInt(winSel.value || '60', 10); const now = Date.now();
      const windowCut = now - maxSecs * 1000;
      const from = activeRange && activeRange.from ? activeRange.from : windowCut;
      const to = activeRange && activeRange.to ? activeRange.to : now;
      const view = buffer.filter(p => p.ts >= windowCut && p.ts >= from && p.ts <= to);
      chart.data.labels = view.map(p => new Date(p.ts).toISOString());
      chart.data.datasets[0].data = view.map(p => p.rx);
      chart.data.datasets[1].data = view.map(p => p.tx);
      chart.update('none');
    }

    // Live badges for current RX/TX
    const badges = makeEl('div', 'mt-2');
    badges.innerHTML = '<span class="badge text-bg-primary me-2" id="rxb">RX: -</span><span class="badge text-bg-success" id="txb">TX: -</span>';
    body.appendChild(badges);
    const rxb = badges.querySelector('#rxb');
    const txb = badges.querySelector('#txb');

    async function pollOnce() {
      const id = devSel.value; const iface = ifSel.value; if (!id || !iface) return;
      try {
        const r = await fetch(`/api/bandwidth/sample?device_id=${id}&interface=${encodeURIComponent(iface)}`);
        const j = await r.json(); const nowTs = Date.now();
        let rxMbps = null, txMbps = null;
        if ('rx_bps' in j) { rxMbps = (j.rx_bps || 0)/1_000_000; txMbps = (j.tx_bps || 0)/1_000_000; }
        else if ('rx_bytes' in j && lastCounters) {
          const dt = (nowTs - lastCounters.ts)/1000; if (dt > 0) {
            const rx_bps = ((j.rx_bytes - lastCounters.rx_bytes)*8)/dt; const tx_bps = ((j.tx_bytes - lastCounters.tx_bytes)*8)/dt;
            rxMbps = Math.max(0, rx_bps)/1_000_000; txMbps = Math.max(0, tx_bps)/1_000_000;
          }
        }
        if ('rx_bytes' in j) lastCounters = { ts: nowTs, rx_bytes: j.rx_bytes, tx_bytes: j.tx_bytes }; else lastCounters = null;
        if (rxMbps != null && txMbps != null) {
          rxb.textContent = `RX: ${rxMbps.toFixed(1)} Mbps`;
          txb.textContent = `TX: ${txMbps.toFixed(1)} Mbps`;
          buffer.push({ ts: nowTs, rx: rxMbps, tx: txMbps });
          trimBuffer();
          renderFromBuffer();
        }
      } catch {}
    }

    function start() {
      if (timer) clearInterval(timer); resetChart(); lastCounters = null; timer = setInterval(pollOnce, 3000);
    }

    devSel.addEventListener('change', loadIfaces);
    ifSel.addEventListener('change', start);
    winSel.addEventListener('change', () => { trimBuffer(); renderFromBuffer(); });
    scaleSel.addEventListener('change', () => applyScale(chart, scaleSel.value));
    hSel.addEventListener('change', () => { canvas.height = parseInt(hSel.value, 10); chart.resize(); });
    applyBtn.addEventListener('click', () => {
      const f = fromInp.value ? Date.parse(fromInp.value) : null;
      const t = toInp.value ? Date.parse(toInp.value) : null;
      activeRange = (f || t) ? { from: f || null, to: t || null } : null;
      renderFromBuffer();
    });
    clearBtn.addEventListener('click', () => { fromInp.value=''; toInp.value=''; activeRange = null; renderFromBuffer(); });
    remBtn.addEventListener('click', () => { if (timer) clearInterval(timer); col.remove(); });

    // default scale: auto
    applyScale(chart, 'auto');
    canvas.height = parseInt(hSel.value, 10);
  }

  addPanelBtn.addEventListener('click', () => createPanel());
  // Start with one panel
  createPanel();
})();
</script>
{% endblock %}


